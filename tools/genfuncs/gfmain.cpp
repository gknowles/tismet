// Copyright Glen Knowles 2018.
// Distributed under the Boost Software License, Version 1.0.
//
// gfmain.cpp - genfuncs
#include "pch.h"
#pragma hdrstop

using namespace std;
using namespace Dim;


/****************************************************************************
*
*   Declarations
*
***/

const char kVersion[] = "1.0.0";


/****************************************************************************
*
*   Helpers
*
***/

//===========================================================================
static string genFuncEnum(string_view fname) {
    Path path(fname);
    ostringstream os;
    os << 1 + R"(
// )" << path.filename() << R"( - tismet func
// Generated by genfuncs )" << kVersion << R"(
// clang-format off
#pragma once


/****************************************************************************
*
*   Declarations
*
***/

namespace Eval {

namespace Function {
    enum Type : int {
)";
    UnsignedSet ids;
    for (auto && f : funcEnums()) {
        if (ids.insert(f.id)) {
            os << "        k" << (char) toupper(*f.name) << f.name + 1
                << " = " << f.id << ",\n";
        }
    }
    os << 1 + R"(
    };
}

namespace Aggregate {
    enum Type : int {
)";
    ids.clear();
    for (auto && f : funcAggEnums()) {
        if (ids.insert(f.id))
            os << "        k" << (char) toupper(*f.name) << f.name + 1
                << " = " << f.id << ",\n";
    }
    os << 1 + R"(
    };
}

} // namespace
)";
    return os.str();
}

//===========================================================================
static string genQueryFunc(string_view fname) {
    Path path(fname);
    ostringstream os;
    os << 1 + R"(
// )" << path.filename() << R"( - tismet query
// Generated by genfuncs )" << kVersion << R"(
// clang-format off
#pragma once


/****************************************************************************
*
*   Query functions
*
***/
)";
    UnsignedSet ids;
    for (auto && f : funcEnums()) {
        if (!ids.insert(f.id))
            continue;
        auto name = string(f.name);
        name[0] = (char) toupper(name[0]);
        os << 1 + R"(

//===========================================================================
inline bool QueryParser::onFn)" << name << R"(Start () {
    return startFunc(Eval::Function::k)" << name << R"();
}
)";
    }
    return os.str();
}

//===========================================================================
static const char * argTypeName(Eval::FuncArgInfo::Type type) {
    switch (type) {
    case Eval::FuncArgInfo::kNum: return "arg-num";
    case Eval::FuncArgInfo::kNumOrString: return "(arg-num / arg-string)";
    case Eval::FuncArgInfo::kQuery: return "arg-query";
    case Eval::FuncArgInfo::kString: return "arg-string";
    default:
        assert(!"Unknown argument type");
        return "arg-invalid";
    }
}

//===========================================================================
static void genAbnfArg(
    ostream & os,
    const Eval::FuncArgInfo & arg,
    bool first
) {
    auto aname = argTypeName(arg.type);
    if (first && arg.multiple) {
        assert(arg.require && "First argument must not be optional");
        os << aname << " *( \",\" " << aname << " ) ";
    } else if (first && !arg.multiple) {
        assert(arg.require && "First argument must not be optional");
        os << aname << ' ';
    } else if (!first && arg.require && arg.multiple) {
        os << "1*( \",\" " << aname << " ) ";
    } else if (!first && arg.require && !arg.multiple) {
        os << "\",\" " << aname << ' ';
    } else if (!first && !arg.require && arg.multiple) {
        os << "*( \",\" " << aname << " ) ";
    } else if (!first && !arg.require && !arg.multiple) {
        os << "[ \",\" " << aname << " ] ";
    }
}

//===========================================================================
static string genQueryAbnf(string_view fname) {
    Path path(fname);
    ostringstream os;
    os << 1 + R"(
; )" << path.filename() << R"( - tismet query
; Generated by genfuncs )" << kVersion << R"(

;----------------------------------------------------------------------------
; Functions
;----------------------------------------------------------------------------
)";
    vector<const Eval::IFuncFactory *> factories;
    for (auto && f : funcFactories())
        factories.push_back(&f);
    sort(factories.begin(), factories.end(), [](auto & a, auto & b) {
        return _stricmp(
            a->m_names.front().c_str(),
            b->m_names.front().c_str()
        ) < 0;
    });
    for (auto && f : factories) {
        os << "func =";
        for (auto && n : f->m_names)
            os << "/ fn-" << n << ' ';
        os << "{ End }\n";
        for (auto && n : f->m_names) {
            os << 1 + R"(
fn-)" << n << R"( = %s")" << n << R"((" )";
            for (unsigned i = 0; i < f->m_args.size(); ++i)
                genAbnfArg(os, f->m_args[i], i == 0);
            os << "\")\" { Start";
            if (&n != f->m_names.data())
                os << ", As fn-" << f->m_names.front();
            os << " }\n";
        }
        os << '\n';
    }
    return os.str();
}

//===========================================================================
static void updateFile(string_view fname, string_view content) {
    string ocontent;
    if (fileExists(fname))
        fileLoadBinaryWait(&ocontent, fname);
    if (ocontent == content) {
        cout << fname << ", no change\n";
    } else {
        auto f = fileOpen(
            fname,
            File::fReadWrite | File::fCreat | File::fTrunc | File::fBlocking
        );
        fileAppendWait(f, content.data(), content.size());
        fileClose(f);
        cout << fname << ", ";
        ConsoleScopedAttr attr(kConsoleHighlight);
        cout << "UPDATED\n";
    }
}


/****************************************************************************
*
*   Application
*
***/

//===========================================================================
static void app(int argc, char * argv[]) {
    Cli cli;
    auto version = string(kVersion) + " (" __DATE__ ")";
    cli.header("genfuncs v"s + version);
    cli.versionOpt(version, "tsm");
    cli.desc("Code generation for metric function enums, abnf, and parser.");
    cli.helpNoArgs();
    auto & root = cli.opt<Path>("<project directory>")
        .desc("Root directory of tismet source code.");
    if (!cli.parse(argc, argv))
        return appSignalUsageError();

    auto sln = *root / "tismet.sln";
    if (!fileExists(sln)) {
        return appSignalUsageError(
            "'" + string(*root) + "' not tismet source root."
        );
    }

    auto funcenum_h = *root / "libs/func/funcenum.h";
    updateFile(funcenum_h, genFuncEnum(funcenum_h));
    auto query_h = *root / "libs/query/queryparsefuncint.h";
    updateFile(query_h, genQueryFunc(query_h));
    auto query_abnf = *root / "libs/query/queryfunc.abnf";
    updateFile(query_abnf, genQueryAbnf(query_abnf));

    appSignalShutdown();
}


/****************************************************************************
*
*   main
*
***/

//===========================================================================
int main(int argc, char *argv[]) {
    _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF
        | _CRTDBG_LEAK_CHECK_DF
//        | _CRTDBG_DELAY_FREE_MEM_DF
    );
    _set_error_mode(_OUT_TO_MSGBOX);

    int code = appRun(app, argc, argv);
    return code;
}
